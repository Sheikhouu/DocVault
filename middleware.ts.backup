import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

// Rate limiting storage
const rateLimitMap = new Map<string, { count: number; resetTime: number }>()

// Rate limiting configuration
const RATE_LIMIT_WINDOW = 60 * 1000 // 1 minute
const MAX_REQUESTS_PER_WINDOW = 60

function getRateLimitKey(request: NextRequest): string {
  // Use IP address or fallback to a header-based identifier
  const ip = request.ip || 
    request.headers.get('x-forwarded-for')?.split(',')[0] ||
    request.headers.get('x-real-ip') ||
    'unknown'
  return ip
}

function isRateLimited(key: string): boolean {
  const now = Date.now()
  const record = rateLimitMap.get(key)

  if (!record || now > record.resetTime) {
    rateLimitMap.set(key, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
    return false
  }

  record.count++
  
  if (record.count > MAX_REQUESTS_PER_WINDOW) {
    return true
  }

  return false
}

export async function middleware(request: NextRequest) {
  // Rate limiting temporairement désactivé pour le debug
  // const rateLimitKey = getRateLimitKey(request)
  // if (isRateLimited(rateLimitKey)) {
  //   console.warn(`Rate limit exceeded for IP: ${rateLimitKey}`)
  //   return new NextResponse('Too Many Requests', {
  //     status: 429,
  //     headers: {
  //       'Retry-After': '60',
  //       'X-RateLimit-Limit': MAX_REQUESTS_PER_WINDOW.toString(),
  //       'X-RateLimit-Remaining': '0',
  //       'X-RateLimit-Reset': (Date.now() + RATE_LIMIT_WINDOW).toString(),
  //     },
  //   })
  // }

  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: any) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  // Refresh session if expired - required for Server Components
  // https://supabase.com/docs/guides/auth/server-side/nextjs
  await supabase.auth.getUser()

  const { data: { user } } = await supabase.auth.getUser()

  // Debug logs
  console.log('🔍 Middleware debug:', { 
    pathname: request.nextUrl.pathname, 
    hasUser: !!user,
    userEmail: user?.email 
  })

  // Define route categories
  const protectedRoutes = ['/dashboard', '/documents', '/settings']
  const authRoutes = ['/signin', '/signup', '/reset-password']
  // Note: /update-password should be accessible with valid session for password reset
  
  const { pathname } = request.nextUrl

  // Check if current path is protected
  const isProtectedRoute = protectedRoutes.some(route => pathname.startsWith(route))
  const isAuthRoute = authRoutes.some(route => pathname.startsWith(route))
  const isUpdatePasswordRoute = pathname.startsWith('/update-password')

  // Redirect unauthenticated users from protected routes
  if (isProtectedRoute && !user) {
    console.log('🚫 Redirecting to signin:', { pathname, reason: 'no user' })
    const redirectUrl = new URL('/signin', request.url)
    redirectUrl.searchParams.set('redirectTo', pathname)
    return NextResponse.redirect(redirectUrl)
  }

  // Redirect authenticated users from auth routes (except update-password)
  if (isAuthRoute && user) {
    console.log('✅ Redirecting to dashboard:', { pathname, reason: 'user already authenticated' })
    return NextResponse.redirect(new URL('/dashboard', request.url))
  }

  // Allow access to update-password route for users with valid sessions (password reset flow)
  // This route requires authentication but shouldn't redirect to dashboard

  return response
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder (public assets)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|public).*)',
  ],
} 